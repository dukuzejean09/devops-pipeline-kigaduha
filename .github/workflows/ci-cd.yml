name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

env:
  DOCKER_REGISTRY: ghcr.io
  IMAGE_NAME: pelino-courses/devops-pipeline-kigaduha

jobs:
  # Frontend Build and Test
  frontend-test:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./frontend

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        run: npm ci

      - name: Run linter
        run: npm run lint

      - name: Run tests
        run: npm test

      - name: Build frontend
        run: npm run build

  # Backend Build and Test
  backend-test:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./backend

    steps:
      - uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: "pip"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Run ruff linter
        run: ruff check src/

      - name: Run ruff formatter check
        run: ruff format --check src/

      - name: Run tests
        run: pytest tests/ --cov=src --cov-report=xml

      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          file: ./backend/coverage.xml

  # Security Scanning
  security-scan:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write

    steps:
      - uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@0.24.0
        with:
          scan-type: "fs"
          scan-ref: "."
          format: "sarif"
          output: "trivy-results.sarif"

      - name: Upload Trivy results to GitHub Security
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: "trivy-results.sarif"

  # Build Docker Images
  build-images:
    runs-on: ubuntu-latest
    needs: [frontend-test, backend-test, security-scan]
    if: github.event_name == 'push'
    permissions:
      contents: read
      packages: write

    strategy:
      matrix:
        component: [frontend, backend]

    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-${{ matrix.component }}
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=semver,pattern={{version}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./${{ matrix.component }}
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=registry,ref=${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-${{ matrix.component }}:buildcache
          cache-to: type=registry,ref=${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-${{ matrix.component }}:buildcache,mode=max

  # Deploy to Environment
  deploy:
    runs-on: ubuntu-latest
    needs: build-images
    if: github.ref == 'refs/heads/main'
    environment: production

    steps:
      - uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0

      - name: Configure Azure credentials
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Generate SSH key if not exists
        run: |
          if [ ! -f ~/.ssh/id_rsa.pub ]; then
            ssh-keygen -t rsa -b 4096 -f ~/.ssh/id_rsa -N ""
          fi
          echo "SSH_PUBLIC_KEY=$(cat ~/.ssh/id_rsa.pub)" >> $GITHUB_ENV

      # Commented out to preserve infrastructure and keep same IP address
      # Uncomment this step only if you need to completely recreate infrastructure
      # - name: Clean up existing resources if needed
      #   continue-on-error: true
      #   run: |
      #     if az group exists --name devopspipeline-dev-rg | grep -q true; then
      #       echo "ðŸ—‘ï¸ Removing existing resource group..."
      #       az group delete --name devopspipeline-dev-rg --yes --no-wait
      #       echo "â³ Waiting for deletion..."
      #       for i in {1..60}; do
      #         if az group exists --name devopspipeline-dev-rg | grep -q false; then
      #           echo "âœ… Deleted after $((i*10))s"
      #           break
      #         fi
      #         sleep 10
      #       done
      #     fi

      - name: Terraform Init and Apply
        working-directory: ./terraform
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
        run: |
          # Initialize Terraform
          terraform init

          # Apply with refresh to sync any existing infrastructure
          # The -replace flag on random strings forces new values but keeps other resources
          terraform apply -auto-approve \
            -var="subscription_id=${{ secrets.AZURE_SUBSCRIPTION_ID }}" \
            -var="client_id=${{ secrets.AZURE_CLIENT_ID }}" \
            -var="client_secret=${{ secrets.AZURE_CLIENT_SECRET }}" \
            -var="tenant_id=${{ secrets.AZURE_TENANT_ID }}" \
            -var="ssh_public_key=${SSH_PUBLIC_KEY}" \
            -replace="random_string.acr_suffix" \
            -replace="random_string.storage_suffix"

      - name: Get Terraform outputs
        id: tf_output
        working-directory: ./terraform
        run: |
          echo "vm_public_ip=$(terraform output -raw vm_public_ip)" >> $GITHUB_OUTPUT
          echo "acr_login_server=$(terraform output -raw acr_login_server)" >> $GITHUB_OUTPUT

      - name: Install Ansible
        run: |
          pip install ansible
          ansible-galaxy collection install azure.azcollection community.docker

      - name: Get short SHA for image tag
        id: short_sha
        run: echo "short_sha=$(git rev-parse --short=7 HEAD)" >> $GITHUB_OUTPUT

      - name: Run Ansible deployment
        working-directory: ./ansible
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          DOCKER_REGISTRY: ${{ env.DOCKER_REGISTRY }}
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
          REGISTRY_USERNAME: ${{ github.actor }}
          REGISTRY_PASSWORD: ${{ secrets.GITHUB_TOKEN }}
          IMAGE_TAG: ${{ github.ref_name }}-${{ steps.short_sha.outputs.short_sha }}
          DB_USER: postgres
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          DB_NAME: taskdb
          SECRET_KEY: ${{ secrets.APP_SECRET_KEY }}
        run: |
          # Create static inventory with VM IP
          mkdir -p inventory
          cat > inventory/hosts.ini <<EOF
          [azure_vms]
          ${{ steps.tf_output.outputs.vm_public_ip }} ansible_user=azureuser ansible_ssh_private_key_file=~/.ssh/id_rsa ansible_ssh_common_args='-o StrictHostKeyChecking=no'
          EOF

          # Wait for VM to be ready
          sleep 60

          # Test connectivity
          ansible all -m ping -i inventory/hosts.ini

          # Deploy application
          ansible-playbook playbooks/setup-server.yml -i inventory/hosts.ini -vv

      - name: Display deployment URL
        run: |
          echo "Deployment completed!"
          echo "Frontend URL: http://${{ steps.tf_output.outputs.vm_public_ip }}"
          echo "Backend API: http://${{ steps.tf_output.outputs.vm_public_ip }}:5000"
